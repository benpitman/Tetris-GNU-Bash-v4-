#!/bin/bash

: <<"TetrisDoc"
    @Param      bool    1
        True if script is to be run in debug mode
    @Param      string  2
        Replay mode file to be used as input log
TetrisDoc

if (( ${BASH_VERSINFO[0]} < 4 )); then
    echo "Incorrect Bash version. Requires 4.3 or later"
    exit 1
fi
if (( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} < 3 )); then
    echo "Incorrect Bash version. Requires 4.3 or later"
    exit 1
fi
if [[ -n "$1" && ! "$1" =~ 0|1 ]]; then
    echo "First parameter must be 1 or 0"
    exit 1
fi

intrap ()
{
    tput cvvis
    printf "\e[0m\e[24;1H\n"
    exit 0
}
trap intrap INT
trap "stty sane" EXIT

declare -g -- _alertTimeout=0
declare -g -- _colourMode=
declare -g -- _currentPiece=
declare -g -- _debug=${1:-0}
declare -g -- _direction=
declare -g -- _gameMode="NORMAL"
declare -g -- _ghosting="INACTIVE"
declare -g -- _ghostingIsSet=0
declare -g -- _ghostY=
declare -g -- _inTTY=
declare -g -- _level=
declare -g -- _lines=
declare -g -- _logging="INACTIVE"
declare -g -- _loggingIsSet=0
declare -g -- _newPiece=1
declare -g -- _nextPiece=
declare -g -- _pieceX=
declare -g -- _pieceY=
declare -g -- _replay=0
declare -g -- _replayIndex=0
declare -g -- _rotation=
declare -g -- _score=0
declare -g -- _state=0

declare -ag -- _replayInputs=()

declare -Ag _selected=(
    ["main"]=0
    ["settings"]=0
)

if [[ -n "$2" && -s "$2" ]]; then
    _replay=1
    _replayInputs=( $( fold -b1 "$2" ) )
    _state=1
fi

stty -echo  # Disable echo
tput civis  # Disable cursor blinker

# If game is loaded on a terminal outside of a GUI environment
if [[ "$DISPLAY" == "" ]] || [[ "$TERM" == "linux" ]]; then
    _inTTY=1
    _colourMode="SIMPLE"
else
    _inTTY=0
    _colourMode="NORMAL"
fi

# Import the assets
for asset in Assets/*; do
    source "$asset"
done
unset asset

setColours
touch "$HIGHSCORE_LOG" # Create score log if doesn"t exist

if (( $_debug )); then
    # Debug mode sends STDERR to an error file
    exec 2>"$DEBUG_LOG"
    set -xT
else
    exec 2>"$ERROR_LOG"
fi

ghostPiece ()
{
    local -- firstLoop=1
    local -- nextY=$_pieceY

    _ghostY=$nextY
    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        firstLoop=0
        _ghostY=$nextY
    done
    $firstLoop && return

    renderGhost "$_currentPiece" $_ghostY $_pieceX
}

setDefaults ()
{
    if  (( $_replay )); then
        _currentPiece=${_replayInputs[$(( _replayIndex++ ))]}
    else
        if [[ "$_nextPiece" != "" ]]; then
            _currentPiece=$_nextPiece
        else
            _currentPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
        fi

        _nextPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
    fi

    # Starting geometry for new pieces
    _rotation=0
    _newPiece=0
    _pieceX=${START_POSITION#*,}
    _pieceY=${START_POSITION%,*}

    movePiece 3
}

replayGameLoop ()
{
    local -- updatePosition=0
    local -- _newPiece=1

    local -- unixTime

    while true; do
        if [[ "${_replayInputs[$_replayIndex]}" == "" ]]; then
            alert "END_REPLAY"
            intrap
        fi
        if (( $_newPiece )); then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            (( $? )) && continue

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            (( $_ghostingIsSet )) && ghostPiece
            clearBuffer
        elif (( $updatePosition )); then
            movePiece 0
            updatePosition=0
            (( $_newPiece )) && continue
        fi

        case ${_replayInputs[$(( _replayIndex++ ))]} in
            ("R") {
                movePiece 1
            };;
            ($UP) {
                _direction=$UP
                movePiece 2
            };;
            ($DOWN) {
                _direction=$DOWN
                updatePosition=1
            };;
            ($RIGHT) {
                _direction=$RIGHT
                updatePosition=1
            };;
            ($LEFT) {
                _direction=$LEFT
                updatePosition=1
            };;
        esac

        printf -v unixTime "%(%s)T" -1
        (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert "CLEAR"

        sleep 0.004
    done
}

gameLoop ()
{
    local -- key1
    local -- key2
    local -- key3
    local -- updatePosition=0
    local -- postTime
    local -- preTime
    local -- tick

    local -i -- readStatus=0
    local -i -- speed
    local -i -- timeTaken=0
    local -i -- unixTime

    while true; do
        if (( $_newPiece )); then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            if (( $? )); then
                renderPiece "$_currentPiece" $_pieceY $_pieceX
                alert "GAME_OVER"
                setState "SCORES"
                return
            fi

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            (( $_ghostingIsSet )) && ghostPiece
            renderNextPiece
            clearBuffer
        elif (( $updatePosition )); then
            movePiece 0
            updatePosition=0
            (( $_newPiece )) && continue
        fi

        preTime=$( date "+%2N" )
        preTime=${preTime#0}

        # Lower numer means faster speed
        (( speed = 90 - $_level * 4 ))
        (( $speed < 20 )) && speed=20

        (( tick = $speed - $timeTaken ))
        (( $tick < 0 )) && tick=0
        (( $tick < 10 )) && tick="0$tick"

        # Read STDIN with the timeout relative to the speed
        IFS= read -rsn1 -t0.$tick key1
        readStatus=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $readStatus != 142 )); then
            # If enter or space is pressed
            if [[ "$key1" == "" ]] || [[ "$key1" == " " ]]; then
                movePiece 1
                sleep 0.05
            elif [[ "$key1" == [Pp] ]] && [[ "$key2" == "" && "$key3" == "" ]]; then
                pause
            elif [[ "$key1" == $'\e' ]] && [[ "$key2" != "" ]]; then # If escape character is pressed
                case $key3 in
                    ($UP) {
                        _direction=$UP
                        movePiece 2
                    };;
                    ($DOWN) {
                        _direction=$DOWN
                        updatePosition=1
                    };;
                    ($RIGHT) {
                        _direction=$RIGHT
                        updatePosition=1
                    };;
                    ($LEFT) {
                        _direction=$LEFT
                        updatePosition=1
                    };;
                esac
            fi
        fi

        postTime=$( date "+%2N" )
        postTime=${postTime#0}

        (( $postTime < $preTime )) && (( postTime += 100 ))
        if (( $timeTaken )); then
            (( timeTaken += $postTime - $preTime ))
        else
            (( timeTaken = $postTime - $preTime ))
        fi

        if (( $timeTaken >= $speed )); then
            updatePosition=1
            _direction=$DOWN
            timeTaken=0

            printf -v unixTime "%(%s)T" -1
            (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert "CLEAR"
        fi

        unset key1 key2 key3
    done
}

# Set BLANK global variables to allow restarting
newGame ()
{
    _level=0
    _lines=0

    # Collision detection
    unset _lock
    declare -Ag -- _lock[{2..23},{2..20..2}]=${COLOURS_LOOKUP[R]}

    # Truncate input log file
    (( $_loggingIsSet )) && : > "$INPUT_LOG"

    # scoreModifier false
     (( $_replay )) && replayGameLoop || gameLoop
    return $?
}

while true; do
    case $_state in
        (*) {
            renderScreen
        };;&
        (1) {
            newGame
        };;
    esac
done
