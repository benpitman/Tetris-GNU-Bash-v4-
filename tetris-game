#!/bin/bash

: <<"TetrisDoc"
    @Param      bool    1
        True if script is to be run in debug mode
    @Param      string  2
        Replay mode file to be used as input log
TetrisDoc

if (( ${BASH_VERSINFO[0]} < 4 )); then
    echo "Incorrect Bash version. Requires 4.3 or later"
    exit 1
fi
if (( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} < 3 )); then
    echo "Incorrect Bash version. Requires 4.3 or later"
    exit 1
fi
if test -n "$1" && ! [[ "$1" =~ true|false ]]; then
    echo "First parameter must be true or false"
    exit 1
fi

intrap ()
{
    tput cvvis
    printf "\e[0m\e[24;1H\n"
    exit 0
}
trap intrap INT
trap "stty sane" EXIT

declare -g -- _colourMode=
declare -g -- _currentPiece=
declare -g -- _debug=${1:-false}
declare -g -- _direction=
declare -g -- _gameMode="NORMAL"
declare -g -- _ghosting="INACTIVE"
declare -g -- _ghostingIsSet=false
declare -g -- _inTTY=
declare -g -- _logging="INACTIVE"
declare -g -- _loggingIsSet=false
declare -g -- _nextPiece=
declare -g -- _replay=false

declare -ig -- _alertTimeout=0
declare -ig -- _ghostY=
declare -ig -- _level=
declare -ig -- _lines=
declare -ig -- _pieceX=
declare -ig -- _pieceY=
declare -ig -- _replayIndex=0
declare -ig -- _rotation=
declare -ig -- _score=0
declare -ig -- _state=0

declare -ag -- _replayInputs=()

declare -Ag _selected=(
    ["main"]=0
    ["settings"]=0
)

if test -n "$2" -a -s "$2"; then
    _replay=true
    _replayInputs=( $( fold -b1 "$2" ) )
    _state=1
fi

stty -echo  # Disable echo
tput civis  # Disable cursor blinker

# If game is loaded on a terminal outside of a GUI environment
if [[ "$DISPLAY" == "" ]] || [[ "$TERM" == "linux" ]]; then
    _inTTY=true
    _colourMode="SIMPLE"
else
    _inTTY=false
    _colourMode="NORMAL"
fi

# Import the assets
for asset in Assets/*; do
    source "$asset"
done
unset asset

setColours
touch "$HIGHSCORE_LOG" # Create score log if doesn"t exist

if $_debug; then
    # Debug mode sends STDERR to an error file
    exec 2>"$DEBUG_LOG"
    set -xT
else
    exec 2>"$ERROR_LOG"
fi

movePiece ()
{
    local -i -- nextX=$_pieceX
    local -i -- nextY=$_pieceY

    case $_direction in
        ($DOWN) {
            timeTaken=0 # Reset timer
            (( nextY++ ))
        };;
        ($RIGHT) {
            (( nextX += 2 ))
        };;
        ($LEFT) {
            (( nextX -= 2 ))
        };;
    esac

    canRender "$_currentPiece" $nextY $nextX

    if (( $? == 0 )); then
        removePiece "$_currentPiece" $_pieceY $_pieceX
        [[ "$_direction" != "$DOWN" ]] && $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

        _pieceX=$nextX
        _pieceY=$nextY

        [[ "$_direction" != "$DOWN" ]] && $_ghostingIsSet && ghostPiece
        renderPiece "$_currentPiece" $_pieceY $_pieceX
    elif [[ "$_direction" == "$DOWN" ]]; then
        lockPiece "$_currentPiece" $_pieceY $_pieceX
        newPiece=true
    fi

    $_loggingIsSet && logInput "TRANSLATE"
}

rotatePiece ()
{
    if [[ "$_gameMode" == "ROTATE" ]]; then
        (( $_rotation == 3 )) && return
    fi

    local -- captureRotation=$_rotation
    local -i -- xPos=$_pieceX
    local -i -- yPos=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX
    $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

    (( _rotation == 3 ? _rotation = 0 : _rotation++ ))

    while true; do
        canRender "$_currentPiece" $yPos $xPos

        case $? in
            (0) {
                break
            };;
            (1) {
                (( xPos -= 2 ))
            };; # Right wall
            (3) {
                (( xPos += 2 ))
            };; # Left wall
            (2|4) {
                _rotation=$captureRotation
                renderPiece "$_currentPiece" $_pieceY $_pieceX
                return
            };; # Floor or another tetromino
        esac
    done

    _pieceX=$xPos
    _pieceY=$yPos

    $_ghostingIsSet && ghostPiece
    renderPiece "$_currentPiece" $_pieceY $_pieceX
    $_loggingIsSet && logInput "ROTATE"
}

dropPiece ()
{
    local nextY=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX

    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        _pieceY=$nextY
    done

    renderPiece "$_currentPiece" $_pieceY $_pieceX
    lockPiece "$_currentPiece" $_pieceY $_pieceX
    newPiece=true
    $_loggingIsSet && logInput "TRANSLATE"
}

ghostPiece ()
{
    local    -- firstLoop=true
    local -i -- nextY=$_pieceY

    _ghostY=$nextY
    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        firstLoop=false
        _ghostY=$nextY
    done
    $firstLoop && return

    renderGhost "$_currentPiece" $_ghostY $_pieceX
}

setDefaults ()
{
    if $_replay; then
        _currentPiece=${_replayInputs[$(( _replayIndex++ ))]}
    else
        if [[ "$_nextPiece" != "" ]]; then
            _currentPiece=$_nextPiece
        else
            _currentPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
        fi

        _nextPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
    fi

    # Starting geometry for new pieces
    _rotation=0
    IFS="," read _pieceY _pieceX <<< $START_POSITION
    newPiece=false
    $_loggingIsSet && logInput "PIECE"
}

logInput ()
{
    case "$1" in
        ("PIECE") {
            printf "%s" $_currentPiece
        };;
        ("TRANSLATE") {
            printf "%s" $_direction
        };;
        ("ROTATE") {
            printf "%s" "R"
        };;
    esac >> "$INPUT_LOG"
}

replayGameLoop ()
{
    local -- updatePosition=false
    local -- newPiece=true

    local -i -- unixTime

    while true; do
        if [[ "${_replayInputs[$_replayIndex]}" == "" ]]; then
            alert "END_REPLAY"
            intrap
        fi
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            (( $? )) && continue

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        case ${_replayInputs[$(( _replayIndex++ ))]} in
            ("R") {
                rotatePiece
            };;
            ($UP) {
                _direction=$UP
                dropPiece
            };;
            ($DOWN) {
                _direction=$DOWN
                updatePosition=true
            };;
            ($RIGHT) {
                _direction=$RIGHT
                updatePosition=true
            };;
            ($LEFT) {
                _direction=$LEFT
                updatePosition=true
            };;
        esac

        printf -v unixTime "%(%s)T" -1
        (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert "CLEAR"

        sleep 0.004
    done
}

gameLoop ()
{
    local -- key1
    local -- key2
    local -- key3
    local -- updatePosition=false
    local -- newPiece=true
    local -- postTime
    local -- preTime
    local -- tick

    local -i -- readStatus=0
    local -i -- speed
    local -i -- timeTaken=0
    local -i -- unixTime

    while true; do
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            if (( $? )); then
                renderPiece "$_currentPiece" $_pieceY $_pieceX
                alert "GAME_OVER"
                setState "SCORES"
                return
            fi

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            renderNextPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        preTime=$( date "+%2N" )
        preTime=${preTime#0}

        # Lower numer means faster speed
        (( speed = 90 - $_level * 4 ))
        (( $speed < 20 )) && speed=20

        (( tick = $speed - $timeTaken ))
        (( $tick < 0 )) && tick=0
        (( $tick < 10 )) && tick="0$tick"

        # Read STDIN with the timeout relative to the speed
        IFS= read -rsn1 -t0.$tick key1
        readStatus=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $readStatus != 142 )); then
            # If enter or space is pressed
            if [[ "$key1" == "" ]] || [[ "$key1" == " " ]]; then
                rotatePiece
                sleep 0.05
            elif [[ "$key1" == [Pp] ]] && [[ "$key2" == "" && "$key3" == "" ]]; then
                pause
            elif [[ "$key1" == $'\e' ]] && [[ "$key2" != "" ]]; then # If escape character is pressed
                case $key3 in
                    ($UP) {
                        _direction=$UP
                        dropPiece
                    };;
                    ($DOWN) {
                        _direction=$DOWN
                        updatePosition=true
                    };;
                    ($RIGHT) {
                        _direction=$RIGHT
                        updatePosition=true
                    };;
                    ($LEFT) {
                        _direction=$LEFT
                        updatePosition=true
                    };;
                esac
            fi
        fi

        postTime=$( date "+%2N" )
        postTime=${postTime#0}

        (( $postTime < $preTime )) && (( postTime += 100 ))
        if (( $timeTaken )); then
            (( timeTaken += $postTime - $preTime ))
        else
            (( timeTaken = $postTime - $preTime ))
        fi

        if (( $timeTaken >= $speed )); then
            updatePosition=true
            _direction=$DOWN
            timeTaken=0

            printf -v unixTime "%(%s)T" -1
            (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert "CLEAR"
        fi

        unset key1 key2 key3
    done
}

# Set BLANK global variables to allow restarting
newGame ()
{
    _level=0
    _lines=0

    # Collision detection
    unset _lock
    declare -Ag -- _lock[{2..23},{2..20..2}]=${COLOURS_LOOKUP[R]}

    # Truncate input log file
    $_loggingIsSet && : > "$INPUT_LOG"

    # scoreModifier false
    $_replay && replayGameLoop || gameLoop
    return $?
}

while true; do
    case $_state in
        (*) {
            renderScreen
        };;&
        (1) {
            newGame
        };;
    esac
done
