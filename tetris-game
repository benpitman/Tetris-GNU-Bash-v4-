#!/bin/bash

: <<'TetrisDoc'
    @Param      bool    1
        True if script is to be run in debug mode
    @Param      string  2
        Replay mode file to be used as input log
TetrisDoc

if (( ${BASH_VERSINFO[0]} < 4 )); then
    echo 'Incorrect Bash version. Requires 4.3 or later'
    exit 1
fi
if (( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} < 3 )); then
    echo 'Incorrect Bash version. Requires 4.3 or later'
    exit 1
fi
if test -n "$1" && ! [[ "$1" =~ [Tt][Rr][Uu][Ee]|[Ff][Aa][Ll][Ss][Ee] ]]; then
    echo 'First parameter must be a boolean'
    exit 1
fi

extrap()
{
    stty sane
    tput cvvis
    printf '\e[25;1H\e[0m'
}
trap extrap EXIT

declare -g _alertTimeout=0
declare -g _colourMode=
declare -g _currentPiece=
declare -g _debug=${1:-false}
declare -g _gameMode='NORMAL'
declare -g _ghosting='INACTIVE'
declare -g _ghostingIsSet=false
declare -g _ghostY=
declare -g _inTTY=
declare -g _level=
declare -g _lines=
declare -g _logging='INACTIVE'
declare -g _loggingIsSet=false
declare -g _nextPiece=
declare -g _pieceX=
declare -g _pieceY=
declare -g _replay=false
declare -g _replayIndex=0
declare -ag _replayInputs=
declare -g _rotation=
declare -g _score=0
declare -g _state=0

declare -Ag _selected=(
    ['main']=0
    ['settings']=0
)

if test -n "$2" -a -s "$2"; then
    _replay=true
    _replayInputs=( $( fold -b1 "$2" ) )
    _state=1
fi

stty -echo  # Disable echo
tput civis  # Disable cursor blinker

# If game is loaded on a terminal outside of a GUI environment
if test -z "$DISPLAY" || [[ "$TERM" == "linux" ]]; then
    _inTTY=true
    _colourMode='SIMPLE'
else
    _inTTY=false
    _colourMode='NORMAL'
fi

# Import the assets
for asset in Assets/*; do
    source "$asset"
done
unset asset

setColours
touch "$HIGHSCORE_LOG" # Create score log if doesn't exist

#TODO Populate settings based of a file if it exists
if test -s "$SETTINGS_LOG" && ! $_replay; then
    :
fi

if $_debug; then
    # Debug mode sends STDERR to an error file
    exec 2>~/debug.log
    set -xT
else
    exec 2>"$ERROR_LOG"
fi

movePiece()
{
    local               \
        nextX=$_pieceX  \
        nextY=$_pieceY

    case $direction in
        $DOWN)  timeTaken=0 # Reset timer
                (( nextY++ ));;
        $RIGHT) (( nextX += 2 ));;
        $LEFT)  (( nextX -= 2 ));;
    esac

    canRender "$_currentPiece" $nextY $nextX

    if (( $? == 0 )); then
        removePiece "$_currentPiece" $_pieceY $_pieceX
        [[ "$direction" != "$DOWN" ]] && $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

        _pieceX=$nextX
        _pieceY=$nextY

        [[ "$direction" != "$DOWN" ]] && $_ghostingIsSet && ghostPiece
        renderPiece "$_currentPiece" $_pieceY $_pieceX
    elif [[ "$direction" == "$DOWN" ]]; then
        lockPiece "$_currentPiece" $_pieceY $_pieceX
        newPiece=true
    fi

    $_loggingIsSet && logInput 'TRANSLATE'
}

rotatePiece()
{
    if [[ "$_gameMode" == 'ROTATE' ]]; then
        (( $_rotation == 3 )) && return
    fi

    local                           \
        captureRotation=$_rotation  \
        posX=$_pieceX               \
        posY=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX
    $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

    (( _rotation == 3 ? _rotation = 0 : _rotation++ ))

    while true; do
        canRender "$_currentPiece" $posY $posX

        case $? in
            0)      break;;
            1)      (( posX -= 2 ));; # Right wall
            3)      (( posX += 2 ));; # Left wall
            2|4)    _rotation=$captureRotation
                    renderPiece "$_currentPiece" $_pieceY $_pieceX
                    return;; # Floor or another tetromino
        esac
    done

    _pieceX=$posX
    _pieceY=$posY

    $_ghostingIsSet && ghostPiece
    renderPiece "$_currentPiece" $_pieceY $_pieceX
    $_loggingIsSet && logInput 'ROTATE'
}

dropPiece()
{
    local nextY=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX

    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        _pieceY=$nextY
    done

    renderPiece "$_currentPiece" $_pieceY $_pieceX
    lockPiece "$_currentPiece" $_pieceY $_pieceX
    newPiece=true
    $_loggingIsSet && logInput 'TRANSLATE'
}

ghostPiece()
{
    local               \
        firstLoop=true  \
        nextY=$_pieceY

    _ghostY=$nextY
    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        firstLoop=false
        _ghostY=$nextY
    done
    $firstLoop && return

    renderGhost "$_currentPiece" $_ghostY $_pieceX
}

setDefaults()
{
    if $_replay; then
        _currentPiece=${_replayInputs[$(( _replayIndex++ ))]}
    else
        test -n "$_nextPiece" && _currentPiece=$_nextPiece || _currentPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
        _nextPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
    fi

    # Starting geometry for new pieces
    _rotation=0
    IFS=',' read _pieceY _pieceX <<< $START_POSITION
    newPiece=false
    $_loggingIsSet && logInput 'PIECE'
}

logInput()
{
    case "$1" in
        'PIECE')        printf '%s' $_currentPiece;;
        'TRANSLATE')    printf '%s' $direction;;
        'ROTATE')       printf '%s' 'R';;
    esac >> "$INPUT_LOG"
}

replayGameLoop()
{
    local                       \
        direction               \
        updatePosition=false    \
        newPiece=true           \
        unixTime

    while true; do
        if test -z "${_replayInputs[$_replayIndex]}"; then
            alert 'END_REPLAY'
            exit 0
        fi
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            (( $? )) && continue

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        case ${_replayInputs[$(( _replayIndex++ ))]} in
            'R')    rotatePiece;;
            $UP)    direction=$UP
                    dropPiece;;
            $DOWN)  direction=$DOWN
                    updatePosition=true;;
            $RIGHT) direction=$RIGHT
                    updatePosition=true;;
            $LEFT)  direction=$LEFT
                    updatePosition=true;;
        esac

        printf -v unixTime '%(%s)T' -1
        (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert 'CLEAR'

        sleep 0.001
    done
}

gameLoop()
{
    local                       \
        direction               \
        key1                    \
        key2                    \
        key3                    \
        updatePosition=false    \
        newPiece=true           \
        postTime                \
        preTime                 \
        readStatus=0            \
        speed                   \
        tick                    \
        timeTaken=0             \
        unixTime

    while true; do
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            if (( $? )); then
                renderPiece "$_currentPiece" $_pieceY $_pieceX
                alert 'GAME_OVER'
                setState 'SCORES'
                return
            fi

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            renderNextPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        preTime=$( date '+%2N' )
        preTime=${preTime#0}

        # Lower numer means faster speed
        (( speed = 90 - $_level * 4 ))
        (( $speed < 20 )) && speed=20

        (( tick = $speed - $timeTaken ))
        (( $tick < 0 )) && tick=0
        (( $tick < 10 )) && tick="0$tick"

        # Read STDIN with the timeout relative to the speed
        IFS= read -rsn1 -t0.$tick key1
        readStatus=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $readStatus != 142 )); then
            # If enter or space is pressed
            if test -z "$key1" || [[ "$key1" == " " ]]; then
                rotatePiece
                sleep 0.05
            elif [[ "$key1" == [Pp] ]] && test -z "$key2" -a -z "$key3"; then
                pause
            # If escape character is pressed
            elif [[ "$key1" == $'\e' ]] && test -n "$key2"; then
                case $key3 in
                    $UP)    direction=$UP
                            dropPiece;;
                    $DOWN)  direction=$DOWN
                            updatePosition=true;;
                    $RIGHT) direction=$RIGHT
                            updatePosition=true;;
                    $LEFT)  direction=$LEFT
                            updatePosition=true;;
                esac
            fi
        fi

        postTime=$( date '+%2N' )
        postTime=${postTime#0}

        (( $postTime < $preTime )) && (( postTime += 100 ))
        if (( $timeTaken )); then
            (( timeTaken += $postTime - $preTime ))
        else
            (( timeTaken = $postTime - $preTime ))
        fi

        if (( $timeTaken >= $speed )); then
            updatePosition=true
            direction=$DOWN
            timeTaken=0

            printf -v unixTime '%(%s)T' -1
            (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert 'CLEAR'
        fi

        unset key1 key2 key3
    done
}

# Set BLANK global variables to allow restarting
newGame()
{
    _level=18
    _lines=0

    # Collision detection
    unset _lock
    declare -Ag _lock[{2..23},{2..20..2}]=${COLOURS_LOOKUP[R]}

    # Truncate input log file
    $_loggingIsSet && : > "$INPUT_LOG"

    # scoreModifier false
    $_replay && replayGameLoop || gameLoop
    return $?
}

while true; do
    case $_state in
        *)  renderScreen;;&
        1)  newGame;;
    esac
done
